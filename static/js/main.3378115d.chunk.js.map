{"version":3,"sources":["components/processinput/ProcessInput.tsx","components/memorydisplay/MemoryDisplay.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["ProcessInput","props","useState","processString","setProcessString","selectedProcess","setSelectedProcess","onRadioClick","event","target","value","onSubmit","onSubmitted","preventDefault","type","pattern","className","onChange","name","checked","MemoryDisplay","fragmentedFilesPercentage","setFilesFragmentedPercentage","fragmentedFilesSpacePercentage","setFragmentedFilesSpacesPercentage","memoryTable","setMemoryTable","processColors","A","B","C","D","E","F","G","H","I","J","K","useEffect","console","log","memory","header","rows","i","push","key","forEach","memoryRow","index","memoryTableCells","map","cell","cellIndex","processColor","filled","process","style","backgroundColor","border","exceptions","indexOf","colSpan","lastMemoryRow","length","allFiles","Array","from","Set","filter","file","undefined","fragmentedFiles","fileToProcess","indicesOfFile","every","indexOfIndex","Math","floor","totalSpaceTaken","reduce","a","b","spaceTakenByFragmentedFiles","displayed","App","memoryString","setMemoryString","showMemory","setShowMemory","displayedMemory","setDisplayedMemory","exceptionRows","setExceptionRows","randomValue","setRandomValue","memoryStates","processes","parseMemoryString","emptyMemory","doesntFit","size","indices","findIndicesOfProcess","processIndex","findFreeIndices","parseInt","split","token","random","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3378115d.chunk.js","sourcesContent":["import React, {ChangeEvent, FormEvent} from 'react';\nimport { FunctionComponent, useState } from 'react';\nimport './ProcessInput.css';\n\nconst ProcessInput: FunctionComponent<\n  {\n    onSubmitted: (process: string) => void\n  }> = (props) => {\n\n  const [processString, setProcessString] = useState('');\n  const [selectedProcess, setSelectedProcess] = useState<'1' | '2' | '3' | ''>('');\n\n\n  const onInput = (event: ChangeEvent) => {\n    setSelectedProcess('');\n    setProcessString((event.target as HTMLInputElement).value);\n  };\n\n  const onRadioClick = (event: ChangeEvent) => {\n    const values = {\n      '1': 'A,2;B,3;A,-;C,4;D,5;B,-;E,5',\n      '2': 'A,4;B,3;C,6;D,5;B,-;E,5;A,-;F,10',\n      '3': 'A,2;B,3;A,-;C,4;D,5;B,-;E,15',\n    };\n\n    setSelectedProcess(((event.target as HTMLInputElement).value as '1' | '2' | '3'));\n    setProcessString(values[((event.target as HTMLInputElement).value as '1' | '2' | '3')]);\n  };\n\n  const onSubmit = (event: FormEvent) => {\n    props.onSubmitted(processString);\n    event.preventDefault();\n  };\n\n\n  return (\n    <form onSubmit={onSubmit}>\n      <h1>OS kodutöö 4, failisüsteemi simulatsioon</h1>\n      <h5>Sander Nemvalts</h5>\n      <h2>Testmuster: </h2>\n      <input type=\"text\"\n             pattern=\"^(([A-Za-z],(\\d|-)+;?){1,12})$\"\n             value={processString}\n             className='pattern-input'\n             onChange={onInput}/>\n\n      <div className=\"radio-container\">\n        <div>\n          <label>\n          <input type=\"radio\"\n                 value='1'\n                 name='first'\n                 checked={selectedProcess === '1'}\n                 onChange={onRadioClick}/>\n          Esimene näidismuster</label>\n        </div>\n        <div>\n          <label>\n          <input type=\"radio\"\n                 value='2'\n                 name='second'\n                 checked={selectedProcess === '2'}\n\n                 onChange={onRadioClick}/>\n          Teine näidismuster</label>\n        </div>\n        <div>\n          <label>\n          <input type=\"radio\"\n                 value='3'\n                 name='third'\n                 checked={selectedProcess === '3'}\n                 onChange={onRadioClick}/>\n          Kolmas näidismuster\n          </label>\n        </div>\n      </div>\n\n      <button type=\"submit\">Näita mälu visualisatsiooni</button>\n    </form>\n  )\n};\n\nexport default ProcessInput;\n","import React, {useState, useEffect} from 'react';\nimport {MemoryCell, MemoryState} from '../../App';\nimport './MemoryDisplay.css';\nconst MemoryDisplay: React.FC<{memory: MemoryState[], displayed: boolean, exceptions: number[]}> = (props) => {\n\n  const [fragmentedFilesPercentage, setFilesFragmentedPercentage] = useState(-1);\n  const [fragmentedFilesSpacePercentage, setFragmentedFilesSpacesPercentage] = useState(-1);\n\n  const [memoryTable, setMemoryTable] = useState();\n\n  const processColors: { [key:string]: string} = {\n    A: '#5C6BC0',\n    B: '#FFEE58',\n    C: '#F48FB1',\n    D: '#9575CD',\n    E: '#42A5F5',\n    F: '#26A69A',\n    G: '#FF9800',\n    H: '#90A4AE',\n    I: '#8D6E63',\n    J: '#D4E157',\n    K: '#FFCA28',\n  };\n\n  useEffect(() => {\n    console.log('memory display', props.memory);\n    const header: JSX.Element[] = [<th></th>];\n    const rows: JSX.Element[] = [];\n\n    for(let i = 0; i < 50; i++) {\n      header.push((<th key={`headercell${i}`}>{i}</th>))\n    }\n\n    props.memory.forEach((memoryRow: MemoryState, index) => {\n      const memoryTableCells = memoryRow.map((cell: MemoryCell, cellIndex) => {\n        let processColor;\n        if (!cell.filled) {\n          processColor = 'white';\n        } else {\n          if (cell.process && processColors[cell.process]) {\n            processColor = processColors[cell.process];\n          } else {\n            processColor = 'red';\n          }\n        }\n        return (<td key={`cell${cellIndex}:${index}`} style={{backgroundColor: processColor, border: '1px solid black'}}>{cell.process}</td>)\n      });\n\n      if (props.exceptions.indexOf(index) > -1) {\n        rows.push(\n          <tr><td>{index}</td><td colSpan={50}>Ei suutnud mahutada!!</td></tr>\n        )\n      } else {\n        rows.push(\n          <tr><td>{index}</td>{memoryTableCells}</tr>\n        )\n      }\n    });\n\n    const lastMemoryRow = props.memory[props.memory.length - 1];\n    const allFiles = Array.from(new Set(lastMemoryRow.map(cell => cell.process)))\n      .filter(file => file !== undefined && file !== '-');\n    let fragmentedFiles = [...allFiles];\n\n    allFiles.forEach((fileToProcess) => {\n      // @ts-ignore\n      const indicesOfFile: number[] = lastMemoryRow\n        .map((file, index) => file.process === fileToProcess ? index : null)\n        .filter(index => index !== null);\n\n\n\n      const isContinuous = indicesOfFile.every((index, indexOfIndex) => {\n        if (indexOfIndex > 0 && indexOfIndex < indicesOfFile.length - 1) {\n          return indicesOfFile[indexOfIndex + 1] === index + 1 && indicesOfFile[indexOfIndex - 1] === index - 1;\n        }\n        return true;\n      });\n\n      if (isContinuous) {\n        fragmentedFiles = fragmentedFiles.filter(file => file !== fileToProcess);\n      }\n    });\n\n    setFilesFragmentedPercentage(Math.floor((fragmentedFiles.length / allFiles.length) * 10000) / 100);\n\n    const totalSpaceTaken = (lastMemoryRow\n      .map(cell => cell.filled ? 1 : 0) as number[])\n      .reduce((a, b) => a + b, 0);\n\n    const spaceTakenByFragmentedFiles = (lastMemoryRow\n      .map(cell => cell.filled && fragmentedFiles.indexOf(cell.process) > -1 ? 1 : 0) as number[])\n      .reduce((a, b) => a + b, 0);\n\n\n    setFragmentedFilesSpacesPercentage(Math.floor((spaceTakenByFragmentedFiles / totalSpaceTaken) * 10000) / 100);\n    setMemoryTable(\n      <table>\n        <thead><tr>{header}</tr></thead>\n        <tbody>{rows}</tbody>\n      </table>\n    );\n\n  }, [props.memory]);\n\n  return (\n    <div className=\"MemoryDisplay\">\n      { props.displayed ? <div>Allesjäänud failidest on fragmenteeritud {fragmentedFilesPercentage}%</div> : null}\n      { props.displayed ? <div>Fragmenteerunud failidele kuulub  {fragmentedFilesSpacePercentage}% kasutatud ruumist</div> : null}\n      {props.displayed ? memoryTable : <span>mälutabel ilmub siia</span>}\n    </div>\n  );\n};\n\n\nexport default MemoryDisplay\n","import React, {useEffect, useState} from 'react';\nimport './App.css';\nimport ProcessInput from './components/processinput/ProcessInput';\nimport MemoryDisplay from './components/memorydisplay/MemoryDisplay';\n\nconst App: React.FC = () => {\n  const [memoryString, setMemoryString] = useState('');\n  const [showMemory, setShowMemory] = useState(false);\n  const [displayedMemory, setDisplayedMemory] = useState<MemoryState[]>([[]]);\n  const [exceptionRows, setExceptionRows] = useState<number[]>([]);\n  const [randomValue, setRandomValue] = useState<number>();\n\n  const handleSubmit = (memoryString: string) => {\n    setMemoryString(memoryString);\n    setRandomValue(Math.random());\n    setShowMemory(true);\n  };\n\n\n\n\n  useEffect(() => {\n    const memoryStates: MemoryState[] = [];\n    const exceptionRows: number[] = [];\n    const processes = parseMemoryString(memoryString);\n\n\n    for (let i = 0; i < processes.length; i++) {\n      let emptyMemory: MemoryCell[] = [];\n      for (let i = 0; i < 50; i++) {\n        emptyMemory.push({\n          filled: false,\n          process: '-'\n        })\n      }\n      memoryStates.push(emptyMemory);\n    }\n\n\n    let doesntFit = false;\n\n    processes.forEach((process, index) => {\n      console.log(process);\n      if (doesntFit) {\n        return;\n      }\n\n      let memory = memoryStates[index];\n\n      const name: string = process[0];\n      const size = process[1];\n\n      if (size === '-') {\n        const indices = findIndicesOfProcess(memory, name);\n\n        for (let i = index; i < memoryStates.length; i++ ){\n          indices.forEach((processIndex) => {\n            memoryStates[i][processIndex] = {\n              filled: false,\n              process: '-',\n            };\n          });\n        }\n      } else {\n        const indices = findFreeIndices(memory, parseInt(size));\n\n        if (indices === -1) {\n          exceptionRows.push(index);\n          doesntFit = true;\n        } else {\n          for (let i = index; i < memoryStates.length; i++ ) {\n            indices.forEach((processIndex) => {\n              memoryStates[i][processIndex] = {\n                filled: true,\n                process: name,\n              }\n            });\n          }\n        }\n      }\n    });\n\n    setDisplayedMemory(memoryStates);\n    setExceptionRows(exceptionRows);\n  }, [memoryString, randomValue]);\n\n\n  const parseMemoryString = (memoryString: string) => {\n    return memoryString.split(';').map(token => token.split(','));\n  };\n\n  const findFreeIndices = (memory: MemoryState, size: number): -1 | number[] => {\n    const indices = [];\n\n    for (let i = 0; i < memory.length; i++) {\n      if (indices.length === size) break;\n      if (!memory[i].filled) {\n        indices.push(i);\n      }\n    }\n\n    if (indices.length !== size) {\n      return -1;\n    } else {\n      return indices;\n    }\n  };\n\n  const findIndicesOfProcess = (memory: MemoryState, name: string) => {\n    const indices = [];\n\n    for (let i = 0; i < memory.length ; i++) {\n      if (memory[i].process === name) {\n        indices.push(i);\n      }\n    }\n\n    return indices;\n  };\n\n  return (\n    <div className=\"App\">\n      <ProcessInput onSubmitted={handleSubmit}/>\n      <MemoryDisplay displayed={showMemory} memory={displayedMemory} exceptions={exceptionRows}/>\n    </div>\n  );\n};\n\n\nconst LastFit = (memory: MemoryState, size: number) => {\n  let lastFilled = -1;\n\n  if (memory.every(cell => !cell.filled)) {\n    if (memory.length >= size) {\n      return 0;\n    }\n  }\n\n  for(let i = 0; i < memory.length; i++) {\n    if (memory[i - 1] && memory[i - 1].filled && !memory[i].filled) {\n      let free = true;\n      for (let j = i; j < i + size; j++) {\n        if (memory[j] === undefined) {\n          free = false;\n          break;\n        }\n\n        if (memory[j].filled) {\n          free = false;\n        }\n      }\n\n\n      if (free) {\n        lastFilled = i;\n      }\n    }\n  }\n\n  return lastFilled;\n};\n\n\nconst BestFit = (memory: MemoryState, size: number) => {\n  const blocks = FindFreeBlocks(memory);\n\n  let bestFitBlock: FreeBlock | null = null;\n\n  blocks.forEach((block: FreeBlock) => {\n    if (size <= block.size) {\n      if (bestFitBlock === null) {\n        bestFitBlock = block;\n      } else if (bestFitBlock !== null && block.size < bestFitBlock.size) {\n        bestFitBlock = block;\n      }\n    }\n  });\n\n  if (bestFitBlock === null) {\n    return -1;\n  } else {\n    // @ts-ignore\n    return bestFitBlock.start;\n  }\n\n};\n\nconst RandomFit = (memory: MemoryState, size: number) => {\n  const blocks = FindFreeBlocks(memory).filter(block => size <= block.size);\n\n  if (blocks.length === 0) {\n    return -1;\n  }\n\n  return blocks[Math.floor(Math.random()*blocks.length)].start;\n};\n\nconst WorstFit = (memory: MemoryState, size: number) => {\n  const blocks = FindFreeBlocks(memory).filter(block => size <= block.size);\n\n  let worstFitBlock: FreeBlock | null = null;\n\n  blocks.forEach((block: FreeBlock) => {\n    if (size <= block.size) {\n      if (worstFitBlock === null) {\n        worstFitBlock = block;\n      } else if (worstFitBlock !== null && block.size > worstFitBlock.size) {\n        worstFitBlock = block;\n      }\n    }\n  });\n\n  if (worstFitBlock === null) {\n    return -1;\n  } else {\n    // @ts-ignore\n    return worstFitBlock.start;\n  }\n};\n\n\nconst FindFreeBlocks = (memory: MemoryState): FreeBlock[] => {\n  const blocks: FreeBlock[] = [];\n\n  let searchingForEnd = false;\n  let blockStart = 0;\n\n  for(let i = 0; i < memory.length; i++) {\n    if (!memory[i].filled && !searchingForEnd) {\n      searchingForEnd = true;\n      blockStart = i;\n    }\n\n    if (memory[i].filled && searchingForEnd) {\n      blocks.push({\n        start: blockStart,\n        size: i - blockStart,\n      });\n      searchingForEnd = false;\n      blockStart = -1;\n    }\n  }\n\n  if (searchingForEnd) {\n    blocks.push({\n      start: blockStart,\n      size: memory.length - blockStart,\n    });\n  }\n\n  return blocks;\n}\n\nexport default App;\n\nexport type MemoryState = MemoryCell[];\n\nexport interface MemoryCell {\n  filled: boolean;\n  process?: string;\n  wontfit?: boolean;\n}\n\nexport interface FreeBlock {\n  start: number;\n  size: number;\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}